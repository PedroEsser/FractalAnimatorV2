#pragma kernel MandelbrotKernel
#include "Assets/UnityUtils/MathUtils/GPU/DD_Complex.hlsl"
#include "Assets/UnityUtils/MathUtils/GPU/Utils.cginc"

RWTexture2D<float4> Result;
StructuredBuffer<float4> OrbitData;

int Width, Height, MaxIterations;
float Bailout;

float4 C0;
int2 C0_Pixel;
float4 Center_Diff;
float2 Scale;    // world units per pixel
int Debug;
float LightDirection;
float LightHeight;

float4 escapeColor(DDComplex z, DDComplex dz, DDComplex zDelta, uint iterations) {
    float smoothIterations = iterations + 1.0 - log2(log(dd_complex_abs(z)));
    float t = log(smoothIterations + 1.0);
    float hue = frac(
        0.3 * sin(t * 1.0) + 
        0.5 * sin(t * 1.618) + 
        0.2 * sin(t * 2.3)
    );

    dz = dd_complex_div(z, dz);
    float2 N = normalize(float2(dz.re.x, dz.im.x));
    float2 L = normalize(float2(cos(LightDirection), sin(LightDirection)));
    float brightness = dot(N, L) + LightHeight;
    brightness /= (1 + LightHeight);
    brightness = max(0, brightness);
    float saturation = smoothIterations * 2 % 2;
    saturation = abs(saturation - 1);
    
    //brightness = 1.0;

    return hsv_to_rgb(float3(hue, saturation, brightness));
}

[numthreads(8,8,1)]
void MandelbrotKernel(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Width || id.y >= Height) return;

    int2 pixel = int2(id.xy);
    if(Debug == 1 && abs(pixel.x - Width/2) < 2 && abs(pixel.y - Height/2) < 2){
        Result[int2(id.xy)] = float4(1, 0, 0, 1);
        return;
    }
    int2 offsetPx = pixel - C0_Pixel;
    if(Debug == 1 && abs(offsetPx.x) < 2 && abs(offsetPx.y) < 2){
        Result[int2(id.xy)] = float4(0, 0, 1, 1);
        return;
    }

    DDComplex delta_c;
    delta_c.re = dd_mul_float(Scale, (float)offsetPx.x);
    delta_c.im = dd_mul_float(Scale, (float)offsetPx.y);
    delta_c.re = dd_add(delta_c.re, Center_Diff.xy);
    delta_c.im = dd_add(delta_c.im, Center_Diff.zw);
    if(Debug == 1 && abs(delta_c.re.x) < 5 * Scale.x && abs(delta_c.im.x) < 5 * Scale.x){
        Result[int2(id.xy)] = float4(0, 1, 0, 1);
        return;
    }

    DDComplex zDelta;
    zDelta.re = dd_make(0.0);
    zDelta.im = dd_make(0.0);

    DDComplex dZ;
    dZ.re = dd_make(0.0);
    dZ.im = dd_make(0.0);

    float escapeIter = (float)MaxIterations;
    float r2 = 0.0;

    for (uint n = 0; n < MaxIterations; n++)
    {
        float4 o = OrbitData[n * 2];
        float4 d = OrbitData[n * 2 + 1];
        DDComplex Zref;
        Zref.re = float2(o.x, o.y);
        Zref.im = float2(o.z, o.w);
        DDComplex dZref;
        dZref.re = float2(d.x, d.y);
        dZref.im = float2(d.z, d.w);

        DDComplex z = dd_complex_add(Zref, zDelta);

        dZ = dd_complex_mul(z, dZ);
        dZ = dd_complex_mul_float(dZ, 2.0);
        dZ.re = dd_add(dZ.re, dd_make(1.0));

        // delta_{n+1} = 2 * Zref * delta_n + delta_n^2 + delta_c
        DDComplex term1 = dd_complex_mul(Zref, zDelta);
        term1 = dd_complex_mul_float(term1, 2.0);

        DDComplex term2 = dd_complex_sqr(zDelta);
        zDelta = dd_complex_add(dd_complex_add(term1, term2), delta_c);

        // z = Zref + delta
        z = dd_complex_add(Zref, zDelta);

        // Escape check using hi part
        r2 = z.re.x * z.re.x + z.im.x * z.im.x;
        if (r2 > Bailout)
        {
            Result[int2(id.xy)] = escapeColor(z, dZ, zDelta, n);
            return;
        }
    }
    Result[int2(id.xy)] = float4(0.0, 0.0, 0.0, 1);
}