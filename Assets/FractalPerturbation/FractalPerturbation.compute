#pragma kernel MandelbrotKernel
#include "Assets/UnityUtils/MathUtils/GPU/DD_Complex.hlsl"
#include "Assets/UnityUtils/MathUtils/GPU/Utils.cginc"

RWTexture2D<float4> Result;
StructuredBuffer<float4> OrbitData;

int Width, Height, MaxIterations;
float Bailout;

float4 C0;
int2 C0_Pixel;
float4 Center_Diff;
float2 Scale;    // world units per pixel
int Debug;
float LightDirection;
float LightHeight;

float4 escapeColor(DDComplex z, DDComplex dz, uint iterations) {
    float smoothIterations = iterations + 1.0 - log2(log(dd_complex_abs(z)));
    float t = log(smoothIterations + 1.0);
    float hue = frac(
        0.3 * sin(t * 1.0) + 
        0.5 * sin(t * 1.618) + 
        0.2 * sin(t * 2.3)
    );

    dz = dd_complex_div(z, dz);
    float2 N = normalize(float2(dz.re.x, dz.im.x));
    float2 L = normalize(float2(cos(LightDirection), sin(LightDirection)));
    float brightness = dot(N, L) + LightHeight;
    brightness /= (1 + LightHeight);
    brightness = max(0, brightness);
    float saturation = smoothIterations * 2 % 2;
    saturation = abs(saturation - 1);
    
    //brightness = 1.0;

    return hsv_to_rgb(float3(hue, saturation, brightness));
}

float4 PerturbationExact(DDComplex delta_c){
    DDComplex zDelta;
    zDelta.re = dd_make(0.0);
    zDelta.im = dd_make(0.0);

    DDComplex dZ;
    dZ.re = dd_make(0.0);
    dZ.im = dd_make(0.0);

    float escapeIter = (float)MaxIterations;
    float r2 = 0.0;

    for (uint n = 0; n < MaxIterations; n++)
    {
        float4 o = OrbitData[n];
        DDComplex Zref;
        Zref.re = float2(o.x, o.y);
        Zref.im = float2(o.z, o.w);

        DDComplex z = dd_complex_add(Zref, zDelta);

        dZ = dd_complex_mul(z, dZ);
        dZ = dd_complex_mul_float(dZ, 2.0);
        dZ.re = dd_add(dZ.re, dd_make(1.0));

        // delta_{n+1} = 2 * Zref * delta_n + delta_n^2 + delta_c
        DDComplex term1 = dd_complex_mul(Zref, zDelta);
        term1 = dd_complex_mul_float(term1, 2.0);

        DDComplex term2 = dd_complex_sqr(zDelta);
        zDelta = dd_complex_add(dd_complex_add(term1, term2), delta_c);

        // z = Zref + delta
        z = dd_complex_add(Zref, zDelta);

        // Escape check using hi part
        r2 = z.re.x * z.re.x + z.im.x * z.im.x;
        if (r2 > Bailout)
        {
            return escapeColor(z, dZ, n);
        }
    }
    return float4(0.0, 0.0, 0.0, 1);
}

float4 PerturbationSeriesApproximation(DDComplex delta_c)
{
    DDComplex delta_c_squared = dd_complex_sqr(delta_c);

    float escapeIter = (float)MaxIterations;
    float r2 = 0.0;

    for (uint n = 0; n < MaxIterations; n++)
    {
        float4 O = OrbitData[n * 3];
        float4 A = OrbitData[n * 3 + 1];
        float4 B = OrbitData[n * 3 + 2];
        DDComplex Zref;
        Zref.re = float2(O.x, O.y);
        Zref.im = float2(O.z, O.w);
        DDComplex Aref;
        Aref.re = float2(A.x, A.y);
        Aref.im = float2(A.z, A.w);
        DDComplex Bref;
        Bref.re = float2(B.x, B.y);
        Bref.im = float2(B.z, B.w);

        Bref = dd_complex_mul(Bref, delta_c_squared);
        Aref = dd_complex_mul(Aref, delta_c);

        DDComplex z = dd_complex_add(Zref, dd_complex_add(Aref, Bref));
        r2 = z.re.x * z.re.x + z.im.x * z.im.x;
        if (r2 > Bailout)
        {
            return escapeColor(z, z, n);
        }
    }
    return float4(0.0, 0.0, 0.0, 1);
}



[numthreads(8,8,1)]
void MandelbrotKernel(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Width || id.y >= Height) return;

    int2 pixel = int2(id.xy);
    int2 centerPixelDiff = pixel - int2(Width/2, Height/2);
    if(Debug == 1 && length(centerPixelDiff) < 2){
        Result[int2(id.xy)] = float4(1, 0, 0, 1);
        return;
    }
    int2 offsetPx = pixel - C0_Pixel;
    if(Debug == 1 && length(offsetPx) < 4){
        Result[int2(id.xy)] = float4(0, 0, 1, 1);
        return;
    }

    DDComplex delta_c;
    delta_c.re = dd_mul_float(Scale, (float)offsetPx.x);
    delta_c.im = dd_mul_float(Scale, (float)offsetPx.y);
    delta_c.re = dd_add(delta_c.re, Center_Diff.xy);
    delta_c.im = dd_add(delta_c.im, Center_Diff.zw);
    if(Debug == 1 && abs(delta_c.re.x) < 3 * Scale.x && abs(delta_c.im.x) < 3 * Scale.x){
        Result[int2(id.xy)] = float4(0, 1, 0, 1);
        return;
    }

    Result[int2(id.xy)] = PerturbationExact(delta_c);
    //Result[int2(id.xy)] = PerturbationSeriesApproximation(delta_c);
}


